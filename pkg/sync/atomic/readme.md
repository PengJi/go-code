# 介绍
## 概念
原子操作，意思就是执行的过程不能打断的操作。在针对某个值的原子操作执行过程中，cpu不会再去执行其他针对这个值得操作。
在底层，这会由CPU提供芯片级别的支持，所以绝对有效。
即使在拥有多CPU核心，或者多CPU的计算机系统中，原子操作的保证也是不可撼动的。
Go语言提供了院子操作的包atomic。其中有很多函数可以帮助我们进行原子操作。
但是只能对几种简单类型进行原子操作：int32、int64、uint32、uint64、uintptr和unsafe.Ponter。
atomic为这些简单类型童工了5中操作函数：增或减、比较并交换、载入、存储和交换。

## 为什么选择原子操作
我们知道go语言在sync包中提供了锁的包，但是为什么我们还要使用atomic原子操作呢？总结下来有一下几个原因：
1. 加锁的代价比较耗时，需要上下文切换。即使是在go语言的goroutine中也需要上下文的切换
2. 只是针对基本类型，可以使用原子操作保证线程安全
3. 原子操作在用户态可以完成，性能比互斥锁要高
4. 针对特定需求，原子操作的步骤简单，不需要加锁-操作-解锁 这样的步骤

# 常见操作
* 增减
需要注意的是，第一个参数必须是指针类型的值，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作。

* 载入
载入操作能够保证原子的读变量的值，当读取的时候，任何其他CPU操作都无法对该变量进行读写，其实现机制收到底层硬件的支持。

* 存储
此类操作确保了写变量的原子性，避免其他操作读到了修改变量过程中的脏数据。

* 比较并交换
该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数 old 所记录的值，满足此前提下才进行交换操作。CAS的做法类似操作数据库时常见的乐观锁机制。
需要注意的是，当有大量的goroutine 对变量进行读写操作时，可能导致CAS操作无法成功，这时可以利用for循环多次尝试。

* 交换
相对于CAS，明显此类操作更为暴力直接，并不管变量的旧值是否被改变，直接赋予新值然后返回背替换的值。
